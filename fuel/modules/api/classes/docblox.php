<?php
/**
 * Fuel is a fast, lightweight, community driven PHP5 framework.
 *
 * @package    Fuel
 * @version    1.1
 * @author     Fuel Development Team
 * @license    MIT License
 * @copyright  2010 - 2012 Fuel Development Team
 * @link       http://fuelphp.com
 *
 */

namespace Api;

/**
 * Docblox XML import class
 */
class Docblox
{

	/**
	 * source branch name we're processing
	 */
	protected static $branch = '';

	/**
	 * source major version number we're processing
	 */
	protected static $major = 0;

	/**
	 * source minor version number we're processing
	 */
	protected static $minor = 0;

	/**
	 * selected version id
	 */
	protected static $version_id = 0;

	/**
	 * package the current file being processed is in
	 */
	protected static $current_package = 'Undefined';

	/**
	 * imported XML array
	 */
	protected static $counters = array(
		'files' => 0,
		'classes' => 0,
	);

	/**
	 * imported XML array
	 */
	protected static $xml = array();

	/**
	 * load and verify the Docblox XML file
	 */
	public static function set_xmlfile($file = null)
	{
		// get the docblox XML file
		try
		{
			$xml = \File::read(str_replace('\\', DS, $file), true);
		}
		catch (\Exception $e)
		{
			throw new \Exception('Docblox: Can not read the docblox XML file.');
		}

		// convert it to an array
		static::$xml = \Format::forge($xml, 'xml')->to_array();

		// get the docblox version info
		$docblox = array_shift(static::$xml);

		// and verify it
		if ($docblox !== array('version' => '0.18.1', 'title' => ''))
		{
			throw new \Exception('Docblox: XML has been generated by an unsupported version of Docblox.');
		}
	}

	/**
	 * set and verify the source version and branch
	 */
	public static function set_version($version = null)
	{
		// check if the version is in the correct format
		$version = explode('/', $version);
		if ( ! isset($version[1]))
		{
			throw new \Exception('Docblox: FuelPHP repository version must be in the form "major.minor/branch".');
		}

		// split it in major, minor and branch
		list($version, static::$branch) = $version;

		$version = explode('.', $version);
		if ( ! isset($version[1]))
		{
			throw new \Exception('Docblox: FuelPHP repository version must be in the form "major.minor/branch".');
		}
		list(static::$major, static::$minor) = $version;

		// ask the documentation module if we know this version
		try
		{
			static::$version_id = \Request::forge('documentation/hmvc/versioncheck', false)
				->execute(array('major' => static::$major, 'minor' => static::$minor, 'branch' => static::$branch))
				->response()
				->body;
		}
		catch (\Exception $e)
		{
			try
			{
				static::$version_id = \Request::forge('documentation/hmvc/versioncreate', false)
					->execute(array('major' => static::$major, 'minor' => static::$minor, 'branch' => static::$branch))
					->response()
					->body;
			}
			catch (\Exception $e)
			{
				throw new \Exception('Docblox: FuelPHP repository version "'.static::$major.'.'.static::$minor.'/'.static::$branch.'" could not be created.'."\n".$e->getMessage());
			}
		}
	}


	/**
	 * process a loaded XML file
	 */
	public static function process()
	{
		// do we have all info?
		if (empty(static::$xml))
		{
			throw new \Exception('Docblox: Process failed, no Docblox XML file loaded.');
		}
		if (empty(static::$branch))
		{
			throw new \Exception('Docblox: Process failed, no repository version defined.');
		}

		// deal with possible timeouts with large docblox files
		set_time_limit(0);

		// delete the current docblock data for this version
		if ($docblox = Model_Docblox::query()->where('version_id', '=', static::$version_id)->get())
		{
			static::log('Deleting previously imported information...'."\n");
			foreach($docblox as $db)
			{
				// cascading deletes will take care of the related records
				$db->delete();
			}

			// delete caches too
			\Cache::delete_all('api.version_'.\Session::get('version'));
		}

		static::log('Start processing the XML file...'."\n");

		// any files present in the xml file?
		if (isset(static::$xml['file']))
		{
			// process the files
			foreach (static::$xml['file'] as $num => $file)
			{
				// get the unified file data
				if ($file = static::process_file($file))
				{
					// and save it to the database
					static::save_file($file);
				}
			}
		}
		else
		{
			throw new \Exception('Docblox: Process failed, no source file entries found in the XML file.');
		}

		static::log("\n".'A total of '.static::$counters['files'].' files processed containing '.static::$counters['classes'].' classes...');

		static::log("\n".'XML file successfully processed...');
	}

	/**
	 * save the unified docblox file data to the database
	 */
	protected static function save_file(Array $file)
	{
		// create the docblox record for this file
		static::log('    - saving file data.');

		static::$counters['files']++;

		$docblox = Model_Docblox::forge(array(
			'version_id' => static::$version_id,
			'package' => $file['package'],
			'hash' => $file['hash'],
			'file' => $file['path'],
			'docblock' => serialize($file['docblock']),
			'markers' => serialize($file['markers']),
		));
		$docblox->save();

		// link any file-level constants to it
		static::log('    - saving global constants.');

		foreach($file['constants'] as $constant)
		{
			$constant = Model_Constant::forge(array(
				'parent_id' => $docblox->id,
				'name' => $constant['name'],
				'type' => $constant['type'],
				'value' => is_array($constant['value']) ? serialize($constant['value']) : $constant['value'],
				'namespace' => $constant['namespace'],
				'package' => $constant['package'],
				'docblock' => serialize($constant['docblock']),
			));
			$constant->save();
		}

		// add the file's functions
		static::log('    - saving global functions.');

		foreach($file['functions'] as $function)
		{
			$function = Model_Function::forge(array(
				'parent_id' => $docblox->id,
				'name' => $function['name'],
				'type' => $function['type'],
				'namespace' => $function['namespace'],
				'package' => $function['package'],
				'docblock' => serialize($function['docblock']),
				'arguments' => serialize($function['arguments']),
				'final' => 0,
				'abstract' => 0,
				'static' => 0,
				'visibility' => 'public',
			));
			$function->save();
		}

		// add the classes defined in this file
		static::log('    - saving defined classes.');

		foreach($file['classes'] as $class)
		{
			static::$counters['classes']++;

			$parent = Model_Class::forge(array(
				'docblox_id' => $docblox->id,
				'name' => $class['name'],
				'fullname' => $class['fullname'],
				'namespace' => $class['namespace'],
				'package' => $class['package'],
				'extends' => $class['extends'],
				'abstract' => $class['abstract'] == 'true' ? 1 : 0,
				'final' => $class['final'] == 'true' ? 1 : 0,
				'docblock' => serialize($class['docblock']),
				'properties' => serialize($class['properties']),
			));
			$parent->save();

			foreach($class['constants'] as $constant)
			{
				$constant = Model_Constant::forge(array(
					'parent_id' => $parent->id,
					'name' => $constant['name'],
					'type' => is_array($constant['value']) ? 'array' : $constant['type'],
					'value' => is_array($constant['value']) ? serialize($constant['value']) : $constant['value'],
					'namespace' => $constant['namespace'],
					'package' => $constant['package'],
					'docblock' => serialize($constant['docblock']),
				));
				$constant->save();
			}

			foreach($class['methods'] as $method)
			{
				$method = Model_Function::forge(array(
					'parent_id' => $parent->id,
					'name' => $method['name'],
					'type' => $method['type'],
					'namespace' => $method['namespace'],
					'package' => $method['package'],
					'docblock' => serialize($method['docblock']),
					'arguments' => serialize($method['arguments']),
					'final' => $method['final'] == 'true' ? 1 : 0,
					'abstract' => $method['abstract'] == 'true' ? 1 : 0,
					'static' => $method['static'] == 'true' ? 1 : 0,
					'visibility' => $method['visibility'],
				));
				$method->save();
			}
		}

		static::log('  - data saved to the database.');
	}

	/**
	 * process file level data and unify it
	 */
	protected static function process_file(Array $file)
	{
		// array to store the unified file data
		$data = array();

		// file attributes
		static::log('- processing '.$file['@attributes']['path'].'...');
		$data['path'] = $file['@attributes']['path'];
		$data['hash'] = $file['@attributes']['hash'];
		$data['package'] = isset($file['@attributes']['package']) ? $file['@attributes']['package'] : 'Undefined';

		// set this package as current
		static::$current_package = $data['package'];

		// file docblock
		if (isset($file['docblock']) and is_array($file['docblock']))
		{
			// process the docblock
			$data['docblock'] = static::process_docblock($file['docblock']);
		}
		else
		{
			// generate a dummy docblock
			$data['docblock'] = static::process_docblock(array());
		}

		// file markers
		$data['markers'] = array();
		if (isset($file['parse_markers']))
		{
			foreach ($file['parse_markers'] as $type => $markers)
			{
				if (is_array($markers))
				{
					// multiple markers of this type
					foreach ($markers as $marker)
					{
						$data['markers'][] = array('type' => $type, 'message' => $marker);
					}
				}
				else
				{
					// single marker of this type
					$data['markers'][] = array('type' => $type, 'message' => $markers);
				}
			}
		}

		// file includes
		$data['includes'] = array();
		// *TODO* - skipped for the moment

		// file constants
		$data['constants'] = array();
		isset($file['constant']) and $data['constants'] = static::process_constant($file['constant']);

		// file functions
		$data['functions'] = array();
		isset($file['function']) and $data['functions'] = static::process_function($file['function']);

		// file classes
		$data['classes'] = array();
		isset($file['class']) and $data['classes'] = static::process_class($file['class']);

		// return the unified data
		return $data;
	}

	/**
	 * process a docblock data block and unify it
	 */
	protected static function process_docblock(Array $docblock, $type = 'file')
	{
		// array to store the unified docblock data
		$data = array();

		// docblock required fields
		$data['description'] = isset($docblock['description']) ? $docblock['description'] : '';
		$data['long-description'] = isset($docblock['long-description']) ? $docblock['long-description'] : '';
		is_array($data['long-description']) or $data['long-description'] = array($data['long-description']);
		$data['since'] = isset($docblock['since']) ? $docblock['since'] : '';
		$data['tags'] = array();

		// docblock supported tags
		if (isset($docblock['tag']) and is_array($docblock['tag']))
		{
			foreach($docblock['tag'] as $tag)
			{
				// normalize the different tag formats
				if (is_string($tag))
				{
					$tag = array('@attributes' => array('name' => $tag));
				}
				elseif ( ! isset($tag['@attributes']))
				{
					$tag['@attributes'] = $tag;
				}

				// defaults for required but not defined tags
				isset($tag['@attributes']['name']) or $tag['@attributes']['name'] = '';
				isset($tag['@attributes']['type']) or $tag['@attributes']['type'] = '';
				isset($tag['@attributes']['description']) or $tag['@attributes']['description'] = '';

				// remove tags we don't need
				unset($tag['@attributes']['line']);

				// store the docblock tag
				$data['tags'][] = $tag['@attributes'];
			}
		}

		// return the unified data
		return $data;
	}

	/**
	 * process a constant data block and unify it
	 */
	protected static function process_constant(Array $constant, $type = 'file')
	{
		// array to store the unified constant data
		$data = array();

		// deal with the different array types
		\Arr::is_assoc($constant) and $constant = array($constant);

		foreach ($constant as $const)
		{
			$data[] = array(
				'name' => isset($const['name']) ? $const['name'] : '',
				'type' => isset($const['type']) ? $const['type'] : 'mixed',
				'value' => isset($const['value']) ? $const['value'] : '',
				'namespace' => isset($const['@attributes']['namespace']) ? $const['@attributes']['namespace'] : 'default',
				'package' => isset($const['@attributes']['package']) ? $const['@attributes']['package'] : static::$current_package,
				'docblock' => static::process_docblock(isset($const['docblock']) ? $const['docblock'] : array(), 'constant'),
			);
		}

		// return the unified data
		return $data;
	}

	/**
	 * process a argument data block and unify it
	 */
	protected static function process_argument(Array $argument, $type = 'file')
	{
		// array to store the unified argument data
		$data = array();

		// deal with the different array types
		\Arr::is_assoc($argument) and $argument = array($argument);

		foreach ($argument as $arg)
		{
			$data[] = array(
				'name' => isset($arg['name']) ? $arg['name'] : '',
				'type' => isset($arg['type']) ? $arg['type'] : '',
				'default' => isset($arg['default']) ? $arg['default'] : '',
			);
		}

		// return the unified data
		return $data;
	}

	/**
	 * process a function data block and unify it
	 */
	protected static function process_function(Array $function, $type = 'file')
	{
		// array to store the unified function data
		$data = array();

		// deal with the different array types
		\Arr::is_assoc($function) and $function = array($function);

		foreach ($function as $func)
		{
			$data[] = array(
				'name' => isset($func['name']) ? $func['name'] : '',
				'type' => isset($func['type']) ? $func['type'] : '',
				'namespace' => isset($func['@attributes']['namespace']) ? $func['@attributes']['namespace'] : 'default',
				'package' => isset($func['@attributes']['package']) ? $func['@attributes']['package'] : static::$current_package,
				'docblock' => static::process_docblock(isset($func['docblock']) ? $func['docblock'] : array(), 'function'),
				'arguments' => static::process_argument(isset($func['argument']) ? $func['argument'] : array(), 'function'),
			);
		}

		// return the unified data
		return $data;
	}

	/**
	 * process a class data block and unify it
	 */
	protected static function process_class(Array $class, $type = 'file')
	{
		// array to store the unified class data
		$data = array();

		// deal with the different array types
		\Arr::is_assoc($class) and $class = array($class);

		foreach ($class as $cls)
		{
			// deal with empty extends tag which converts to an empty array
			is_array($cls['extends']) and $cls['extends'] = '';

			$data[] = array(
				'name' => isset($cls['name']) ? $cls['name'] : '',
				'fullname' => isset($cls['full_name']) ? $cls['full_name'] : '',
				'extends' => isset($cls['extends']) ? $cls['extends'] : '',
				'namespace' => isset($cls['@attributes']['namespace']) ? $cls['@attributes']['namespace'] : 'default',
				'package' => isset($cls['@attributes']['package']) ? $cls['@attributes']['package'] : static::$current_package,
				'final' => isset($cls['@attributes']['final']) ? $cls['@attributes']['final'] : 'false',
				'abstract' => isset($cls['@attributes']['abstract']) ? $cls['@attributes']['abstract'] : 'false',
				'docblock' => static::process_docblock(isset($cls['docblock']) ? $cls['docblock'] : array(), 'class'),
				'properties' => static::process_property(isset($cls['property']) ? $cls['property'] : array(), 'class'),
				'methods' => static::process_method(isset($cls['method']) ? $cls['method'] : array(), 'class'),
				'constants' => static::process_constant(isset($cls['constant']) ? $cls['constant'] : array(), 'class'),
			);
		}

		// return the unified data
		return $data;
	}

	/**
	 * process a property data block and unify it
	 */
	protected static function process_property(Array $property, $type = 'file')
	{
		// array to store the unified property data
		$data = array();

		// deal with the different array types
		\Arr::is_assoc($property) and $property = array($property);

		foreach ($property as $prop)
		{
			$data[] = array(
				'name' => isset($prop['name']) ? $prop['name'] : '',
				'type' => isset($prop['type']) ? $prop['type'] : 'mixed',
				'value' => isset($prop['value']) ? $prop['value'] : '',
				'namespace' => isset($prop['@attributes']['namespace']) ? $prop['@attributes']['namespace'] : 'default',
				'package' => isset($prop['@attributes']['package']) ? $prop['@attributes']['package'] : static::$current_package,
				'final' => isset($prop['@attributes']['final']) ? $prop['@attributes']['final'] : 'false',
				'static' => isset($prop['@attributes']['static']) ? $prop['@attributes']['static'] : 'false',
				'visibility' => isset($prop['@attributes']['visibility']) ? $prop['@attributes']['visibility'] : 'public',
				'docblock' => static::process_docblock(isset($prop['docblock']) ? $prop['docblock'] : array(), 'property'),
			);
		}

		// return the unified data
		return $data;
	}

	/**
	 * process a method data block and unify it
	 */
	protected static function process_method(Array $method, $type = 'file')
	{
		// array to store the unified method data
		$data = array();

		// deal with the different array types
		\Arr::is_assoc($method) and $method = array($method);

		foreach ($method as $meth)
		{
			$data[] = array(
				'name' => isset($meth['name']) ? $meth['name'] : '',
				'type' => isset($meth['type']) ? $meth['type'] : '',
				'namespace' => isset($meth['@attributes']['namespace']) ? $meth['@attributes']['namespace'] : 'default',
				'package' => isset($meth['@attributes']['package']) ? $meth['@attributes']['package'] : static::$current_package,
				'final' => isset($meth['@attributes']['final']) ? $meth['@attributes']['final'] : 'false',
				'abstract' => isset($meth['@attributes']['abstract']) ? $meth['@attributes']['abstract'] : 'false',
				'static' => isset($meth['@attributes']['static']) ? $meth['@attributes']['static'] : 'false',
				'visibility' => isset($meth['@attributes']['visibility']) ? $meth['@attributes']['visibility'] : 'public',
				'docblock' => static::process_docblock(isset($meth['docblock']) ? $meth['docblock'] : array(), 'function'),
				'arguments' => static::process_argument(isset($meth['argument']) ? $meth['argument'] : array(), 'function'),
			);
		}

		// return the unified data
		return $data;
	}

	/**
	 * unify the log messages for oil and interactive use
	 */
	protected static function log($message)
	{
		if (\Fuel::$is_cli)
		{
			\Cli::write($message);
		}
		else
		{
			echo $message."\n";
		}
	}

}
